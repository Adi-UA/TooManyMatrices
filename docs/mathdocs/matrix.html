<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>matrix API documentation</title>
<meta name="description" content="matrix.py: This module defines a Matrix class to represent and perform
operations on matrices. It also provides a couple additional functions to
â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>matrix</code></h1>
</header>
<section id="section-intro">
<p>matrix.py: This module defines a Matrix class to represent and perform
operations on matrices. It also provides a couple additional functions to
quickly generate identity matrices and compare matrix orders. Refer to the HTML
documentation for an indepth explanation.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
matrix.py: This module defines a Matrix class to represent and perform
operations on matrices. It also provides a couple additional functions to
quickly generate identity matrices and compare matrix orders. Refer to the HTML
documentation for an indepth explanation.
&#34;&#34;&#34;
import numpy as np

__author__ = &#34;Aditya Banerjee&#34;
__copyright__ = &#34;Copyright 2020, Aditya Banerjee&#34;
__status__ = &#34;Development&#34;


class Matrix:
    &#34;&#34;&#34;
    This class represents a Matrix. Refer to the HTML documentation for method
    details.
    &#34;&#34;&#34;

    def __init__(self, row_no, col_no):
        &#34;&#34;&#34;
        Creates an object that represents a matrix. During initialization the
        number of rows and columns needs to be given.

        Arguments: row_no {int} -- The number of rows in the matrix col_no {int}
            -- The number of columns in the matrix
        &#34;&#34;&#34;
        self._row_no = row_no
        self._col_no = col_no
        self._matrix = np.array([[0] * col_no] * row_no)

    def __eq__(self, other):
        &#34;&#34;&#34;
        This method checks the equality of two Matrix instances. Two matrices
        are said to be equal if they are of the same size and have the same
        elements at corresponding positions

        Arguments: other {Matrix} -- The Matrix object that the calling matrix
            is compared to

        Returns: boolean -- true if equal and false otherwise
        &#34;&#34;&#34;
        if isinstance(other, Matrix):
            if dimensions_match(self, other):
                comparison = self._matrix == other._matrix
                return comparison.all()
            else:
                return False
        else:
            return False

    def get_row_no(self):
        &#34;&#34;&#34;
        Returns the number of rows in the calling matrix.

        Returns: int -- The number of rows
        &#34;&#34;&#34;
        return self._row_no

    def get_col_no(self):
        &#34;&#34;&#34;
        Returns the number of columns in the calling matrix.

        Returns: int -- The number of columns
        &#34;&#34;&#34;
        return self._col_no

    def get_value(self, row, col):
        &#34;&#34;&#34;
        Returns the matrix value at the given position. Index starts at (1,1)

        Arguments: row {int} -- The row position of the element col {int} -- The
            column position of the element

        Returns: The value stored at (row, col) or None if the position is
            invalid
        &#34;&#34;&#34;
        if row &gt; 0 and col &gt; 0 and row &lt;= self._row_no and col &lt;= self._col_no:
            return self._matrix[row - 1][col - 1]
        else:
            return None

    def set_value(self, row, col, value):
        &#34;&#34;&#34;
        Sets the matrix value at the given position. Index starts at (1,1)

        Arguments: row {int} -- The row position of the element col {int} -- The
            column position of the element
        &#34;&#34;&#34;
        if row &gt; 0 and col &gt; 0 and row &lt;= self._row_no and col &lt;= self._col_no:
            self._matrix[row - 1][col - 1] = value
        else:
            return None

    def _set_matrix_array(self, array):
        &#34;&#34;&#34;
        This private method is used to modify the Matrix objects internal array
        and update its row and column size accordingly. DO NOT USE THIS
        EXTERNALLY.

        Arguments: array {numpy array} -- The 2D numpy array representin a valid
            matrix
        &#34;&#34;&#34;
        self._matrix = array
        self._row_no = len(array)
        self._col_no = len(array[0])

    def insert_all(self, elements):
        &#34;&#34;&#34;
        This method accepts a list of elements and initializes the matrix with
        them. Make sure to pass as many elements in the list as there are spaces
        in the matrix you defined. The Matrix object is modified in place.

        Arguments: elements {list} -- List of elements to put in the matrix

        Returns: boolean -- True if elements were added and False otherwise.
        &#34;&#34;&#34;
        if len(elements) == self._row_no * self._col_no:
            self._matrix = np.reshape(elements, (self._row_no, self._col_no))
            return True
        else:
            return False

    def transpose(self):
        &#34;&#34;&#34;
        This method finds and returns the transpose of the calling object. The
        calling object is NOT modified in place.

        Returns: Matrix -- A reference to the new transposed Matrix object
        &#34;&#34;&#34;
        retval = Matrix(self._col_no, self._row_no)
        retval._matrix = np.transpose(self._matrix)
        return retval

    def det(self):
        &#34;&#34;&#34;
        This method finds the determinant of the calling object.

        Returns: float -- The determinant value rounded up to two places or None
            if the request was invalid
        &#34;&#34;&#34;
        if self._row_no == self._col_no:
            return round(np.linalg.det(self._matrix), 2)
        else:
            return None

    def multiply_scalar(self, scalar):
        &#34;&#34;&#34;
        This method multiplies a scalar coefficient into the matrix.The calling
        object is NOT modified in place.

        Arguments: scalar -- The coefficient to multiply by

        Returns: Matrix -- A reference to the Matrix object with scalar
            multiplication applied
        &#34;&#34;&#34;
        retval = Matrix(self._row_no, self._col_no)
        retval._matrix = self._matrix * scalar
        return retval

    def inv(self):
        &#34;&#34;&#34;
        This method finds the inverse matrix of the calling object.The calling
        object is NOT modified in place.

        Returns: Matrix -- A reference to the inverse matix or None if the
            request was invalid
        &#34;&#34;&#34;
        if self.det() != 0 and self._row_no == self._col_no:
            retval = Matrix(self._row_no, self._col_no)
            inverse_array = np.matrix.round(np.linalg.inv(self._matrix), 2)
            retval._set_matrix_array(inverse_array)
            return retval
        else:
            return None

    def cofactor(self):
        &#34;&#34;&#34;
        This method finds the cofactor matrix of the calling object.The calling
        object is NOT modified in place.

        Returns: Matrix -- A reference to the cofactor matrix or None if the
            request was invalid
        &#34;&#34;&#34;
        if self._row_no == self._col_no:
            retval = Matrix(self._row_no, self._col_no)

            values = []
            for i in range(1, self._row_no + 1):
                for j in range(1, self._col_no + 1):
                    sign_factor = (-1)**(i + j)
                    remaining = self.find_minor(i, j)
                    cofactor = sign_factor * remaining.det()
                    values.append(cofactor)

            retval.insert_all(values)
            return retval
        else:
            return None

    def adjoint(self):
        &#34;&#34;&#34;
        This method finds the adjoint matrix of the calling object.The calling
        object is NOT modified in place.

        Returns: Matrix -- A reference to the adjoint matrix or None if the
            request was invalid
        &#34;&#34;&#34;
        return self.cofactor().transpose()

    def find_minor(self, row, column):
        &#34;&#34;&#34;
        This method finds the minor of the calling object at the given
        position.The calling object is NOT modified in place.

        Arguments: row -- The minor row column -- The minor column

        Returns: Matrix -- A reference to the minor matrix or None if the
            request was invalid
        &#34;&#34;&#34;
        if self._row_no == self._col_no and self._row_no &gt; 1 and self._col_no &gt; 1:
            if row &gt; 0 and column &gt; 0 and row &lt;= self._row_no and column &lt;= self._col_no:
                retval = Matrix(self._row_no - 1, self._col_no - 1)
                values = []

                for i in range(1, self._row_no + 1):
                    for j in range(1, self._col_no + 1):
                        if i == row or j == column:
                            pass
                        else:
                            values.append(self._matrix[i - 1][j - 1])

                retval.insert_all(values)
                return retval
            else:
                return None
        else:
            return None

    def is_boolean(self):
        &#34;&#34;&#34;
        This method checks to see if a matrix is a zero-one matrix. That is, it
        checks to see if all the elements in the matrix are either 0 or one.

        Returns: boolean -- True or False depending on wheter or not it is a
            zero-one matrix or not
        &#34;&#34;&#34;
        for i in range(1, self._row_no + 1):
            for j in range(1, self._col_no + 1):
                value = self._matrix[i - 1][j - 1]
                if value != 1 and value != 0:
                    return False

        return True

    def boolean_power(self, pow):
        &#34;&#34;&#34;
        This method finds the boolean power of the given matrix raised to the
        pow parameter.The calling object is NOT modified in place.

        Arguments: pow -- The power

        Returns: Matrix -- A reference to the resulting matrix or None if the
            request was invalid.For a power of 0 the identity matrix of input
            matrix row size will be returned.
        &#34;&#34;&#34;
        if pow == 0:
            return get_identity_matrix(self._row_no)
        if pow &gt; 0:
            retval = self
            for i in range(pow - 1):
                retval = retval.boolean_product(self)
                if retval is None:
                    return None
            return retval
        else:
            return None

    def boolean_product(self, other):
        &#34;&#34;&#34;
        This method finds the boolean product of the given matries.The calling
        object is NOT modified in place.

        Arguments: other -- The matrix object with which a boolean product is to
            be computed

        Returns: Matrix -- A reference to the resulting matrix or None if the
            request was invalid.
        &#34;&#34;&#34;
        if isinstance(other, Matrix):
            if self._col_no == other._row_no:
                values = []
                for i in range(1, self._row_no + 1):
                    for j in range(1, self._col_no + 1):
                        res_val = 0
                        for k in range(1, self._col_no + 1):
                            value1 = self._matrix[i - 1][k - 1]
                            value2 = other._matrix[k - 1][j - 1]
                            if (value1 == 0 or value1 == 1) and (
                                    value2 == 0 or value2 == 1):
                                res_val = res_val | (value1 &amp; value2)
                            else:
                                return None
                        values.append(res_val)
                retval = Matrix(self._row_no, other._col_no)
                retval.insert_all(values)
                return retval
            else:
                return None
        else:
            return None

    def __add__(self, other):
        &#34;&#34;&#34;
        This method finds the addition of the given matries.The calling object
        is NOT modified in place.

        Arguments: other -- The matrix object to be added

        Returns: Matrix -- A reference to the resulting matrix or None if the
            request was invalid.
        &#34;&#34;&#34;
        if dimensions_match(self, other):
            retval = Matrix(self._row_no, self._col_no)
            retval._matrix = np.add(self._matrix, other._matrix)
            return retval
        else:
            return None

    def __sub__(self, other):
        &#34;&#34;&#34;
        This method finds the subtraction of the given matries.The calling
        object is NOT modified in place.

        Arguments: other -- The matrix object to be subtracted

        Returns: Matrix -- A reference to the resulting matrix or None if the
            request was invalid.
        &#34;&#34;&#34;
        if dimensions_match(self, other):
            retval = Matrix(self._row_no, self._col_no)
            retval._matrix = np.subtract(self._matrix, other._matrix)
            return retval
        else:
            return None

    def __mul__(self, other):
        &#34;&#34;&#34;
        This method finds the multiplication of the given matries.The calling
        object is NOT modified in place.

        Arguments: other -- The matrix object to be multiplied

        Returns: Matrix -- A reference to the resulting matrix or None if the
            request was invalid.
        &#34;&#34;&#34;
        if self._col_no == other._row_no:
            retval = Matrix(self._row_no, other._col_no)
            retval._matrix = np.dot(self._matrix, other._matrix)
            return retval
        else:
            return None

    def __pow__(self, pow):
        &#34;&#34;&#34;
        This method finds the power of the given matrix raised to the pow
        parameter.The calling object is NOT modified in place.

        Arguments: pow -- The power

        Returns: Matrix -- A reference to the resulting matrix or None if the
            request was invalid. For a power of 0 the identity matrix of input
            matrix row size will be returned.
        &#34;&#34;&#34;
        if pow == 0:
            return get_identity_matrix(self._row_no)
        if pow &gt; 0:
            retval = self
            for i in range(pow - 1):
                retval = retval * self
                if retval is None:
                    return None
            return retval
        else:
            return None

    def __lshift__(self, shift_val):
        &#34;&#34;&#34;
        This method left shifts each value in the matrix. The calling object is
        NOT modified in place.

        Arguments: shift_val {int} -- The shift value

        Returns: Matrix -- A reference to the resulting matrix. or None if the
        request was invalid
        &#34;&#34;&#34;

        if isinstance(shift_val, int):
            retval = Matrix(self._row_no, self._col_no)
            for i in range(self._row_no):
                for j in range(self._col_no):
                    if isinstance(self._matrix[i][j], np.int32):
                        retval._matrix[i][j] = self._matrix[i][j] &lt;&lt; shift_val
                    else:
                        return None
            return retval
        else:
            return None

    def __rshift__(self, shift_val):
        &#34;&#34;&#34;
        This method right shifts each value in the matrix. The calling object is
        NOT modified in place.

        Arguments: shift_val {int} -- The shift value

        Returns: Matrix -- A reference to the resulting matrix. or None if the
        request was invalid
        &#34;&#34;&#34;
        if isinstance(shift_val, int):
            retval = Matrix(self._row_no, self._col_no)
            for i in range(self._row_no):
                for j in range(self._col_no):
                    if isinstance(self._matrix[i][j], np.int32):
                        retval._matrix[i][j] = self._matrix[i][j] &gt;&gt; shift_val
                    else:
                        return None
            return retval
        else:
            return None

    def __and__(self, other):
        &#34;&#34;&#34;
        This method finds the elementwise bitwise AND of the given matries.The
        calling object is NOT modified in place.

        Arguments: other -- The matrix object to be AND-ed with

        Returns: Matrix -- A reference to the resulting matrix or None if the
            request was invalid.
        &#34;&#34;&#34;
        if dimensions_match(self, other):
            retval = Matrix(self._row_no, self._col_no)
            retval._matrix = np.bitwise_and(self._matrix, other._matrix)
            return retval
        else:
            return None

    def __or__(self, other):
        &#34;&#34;&#34;
        This method finds the elementwise bitwise OR of the given matries.The
        calling object is NOT modified in place.

        Arguments: other -- The matrix object to be OR-ed with

        Returns: Matrix -- A reference to the resulting matrix or None if the
            request was invalid.
        &#34;&#34;&#34;
        if dimensions_match(self, other):
            retval = Matrix(self._row_no, self._col_no)
            retval._matrix = np.bitwise_or(self._matrix, other._matrix)
            return retval
        else:
            return None

    def __xor__(self, other):
        &#34;&#34;&#34;
        This method finds the elementwise bitwise XOR of the given matries.The
        calling object is NOT modified in place.

        Arguments: other -- The matrix object to be XOR-ed with

        Returns: Matrix -- A reference to the resulting matrix or None if the
            request was invalid.
        &#34;&#34;&#34;
        if dimensions_match(self, other):
            retval = Matrix(self._row_no, self._col_no)
            retval._matrix = np.bitwise_xor(self._matrix, other._matrix)
            return retval
        else:
            return None

    def __str__(self):
        &#34;&#34;&#34;
        This method retruns the string representation of the matrix.

        Returns: str -- The matrix&#39;s string representation
        &#34;&#34;&#34;
        return str(self._matrix)


def dimensions_match(matrix1, matrix2):
    &#34;&#34;&#34;
    This function checks if the orders of the given matrices match.

    Arguments: matrix1 {Matrix} - The first Matrix object matrix2 {Matrix} - The
        second Matrix object

    Returns: boolean-- True or False depending on if their orders match or not.
    &#34;&#34;&#34;
    return matrix1.get_row_no() == matrix2.get_row_no(
    ) and matrix1.get_col_no() == matrix2.get_col_no()


def get_identity_matrix(size):
    &#34;&#34;&#34;
    This method creates and returns an identity Matrix object of the requested
    size.

    Arguments: size {int} -- Size of identity matrix

    Returns: Matrix -- The identity matrix.
    &#34;&#34;&#34;
    retval = Matrix(size, size)
    for i in range(1, size + 1):
        for j in range(1, size + 1):
            if i == j:
                retval.set_value(i, j, 1)
    return retval</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="matrix.dimensions_match"><code class="name flex">
<span>def <span class="ident">dimensions_match</span></span>(<span>matrix1, matrix2)</span>
</code></dt>
<dd>
<div class="desc"><p>This function checks if the orders of the given matrices match.</p>
<p>Arguments: matrix1 {Matrix} - The first Matrix object matrix2 {Matrix} - The
second Matrix object</p>
<p>Returns: boolean&ndash; True or False depending on if their orders match or not.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dimensions_match(matrix1, matrix2):
    &#34;&#34;&#34;
    This function checks if the orders of the given matrices match.

    Arguments: matrix1 {Matrix} - The first Matrix object matrix2 {Matrix} - The
        second Matrix object

    Returns: boolean-- True or False depending on if their orders match or not.
    &#34;&#34;&#34;
    return matrix1.get_row_no() == matrix2.get_row_no(
    ) and matrix1.get_col_no() == matrix2.get_col_no()</code></pre>
</details>
</dd>
<dt id="matrix.get_identity_matrix"><code class="name flex">
<span>def <span class="ident">get_identity_matrix</span></span>(<span>size)</span>
</code></dt>
<dd>
<div class="desc"><p>This method creates and returns an identity Matrix object of the requested
size.</p>
<p>Arguments: size {int} &ndash; Size of identity matrix</p>
<p>Returns: Matrix &ndash; The identity matrix.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_identity_matrix(size):
    &#34;&#34;&#34;
    This method creates and returns an identity Matrix object of the requested
    size.

    Arguments: size {int} -- Size of identity matrix

    Returns: Matrix -- The identity matrix.
    &#34;&#34;&#34;
    retval = Matrix(size, size)
    for i in range(1, size + 1):
        for j in range(1, size + 1):
            if i == j:
                retval.set_value(i, j, 1)
    return retval</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="matrix.Matrix"><code class="flex name class">
<span>class <span class="ident">Matrix</span></span>
<span>(</span><span>row_no, col_no)</span>
</code></dt>
<dd>
<div class="desc"><p>This class represents a Matrix. Refer to the HTML documentation for method
details.</p>
<p>Creates an object that represents a matrix. During initialization the
number of rows and columns needs to be given.</p>
<p>Arguments: row_no {int} &ndash; The number of rows in the matrix col_no {int}
&ndash; The number of columns in the matrix</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Matrix:
    &#34;&#34;&#34;
    This class represents a Matrix. Refer to the HTML documentation for method
    details.
    &#34;&#34;&#34;

    def __init__(self, row_no, col_no):
        &#34;&#34;&#34;
        Creates an object that represents a matrix. During initialization the
        number of rows and columns needs to be given.

        Arguments: row_no {int} -- The number of rows in the matrix col_no {int}
            -- The number of columns in the matrix
        &#34;&#34;&#34;
        self._row_no = row_no
        self._col_no = col_no
        self._matrix = np.array([[0] * col_no] * row_no)

    def __eq__(self, other):
        &#34;&#34;&#34;
        This method checks the equality of two Matrix instances. Two matrices
        are said to be equal if they are of the same size and have the same
        elements at corresponding positions

        Arguments: other {Matrix} -- The Matrix object that the calling matrix
            is compared to

        Returns: boolean -- true if equal and false otherwise
        &#34;&#34;&#34;
        if isinstance(other, Matrix):
            if dimensions_match(self, other):
                comparison = self._matrix == other._matrix
                return comparison.all()
            else:
                return False
        else:
            return False

    def get_row_no(self):
        &#34;&#34;&#34;
        Returns the number of rows in the calling matrix.

        Returns: int -- The number of rows
        &#34;&#34;&#34;
        return self._row_no

    def get_col_no(self):
        &#34;&#34;&#34;
        Returns the number of columns in the calling matrix.

        Returns: int -- The number of columns
        &#34;&#34;&#34;
        return self._col_no

    def get_value(self, row, col):
        &#34;&#34;&#34;
        Returns the matrix value at the given position. Index starts at (1,1)

        Arguments: row {int} -- The row position of the element col {int} -- The
            column position of the element

        Returns: The value stored at (row, col) or None if the position is
            invalid
        &#34;&#34;&#34;
        if row &gt; 0 and col &gt; 0 and row &lt;= self._row_no and col &lt;= self._col_no:
            return self._matrix[row - 1][col - 1]
        else:
            return None

    def set_value(self, row, col, value):
        &#34;&#34;&#34;
        Sets the matrix value at the given position. Index starts at (1,1)

        Arguments: row {int} -- The row position of the element col {int} -- The
            column position of the element
        &#34;&#34;&#34;
        if row &gt; 0 and col &gt; 0 and row &lt;= self._row_no and col &lt;= self._col_no:
            self._matrix[row - 1][col - 1] = value
        else:
            return None

    def _set_matrix_array(self, array):
        &#34;&#34;&#34;
        This private method is used to modify the Matrix objects internal array
        and update its row and column size accordingly. DO NOT USE THIS
        EXTERNALLY.

        Arguments: array {numpy array} -- The 2D numpy array representin a valid
            matrix
        &#34;&#34;&#34;
        self._matrix = array
        self._row_no = len(array)
        self._col_no = len(array[0])

    def insert_all(self, elements):
        &#34;&#34;&#34;
        This method accepts a list of elements and initializes the matrix with
        them. Make sure to pass as many elements in the list as there are spaces
        in the matrix you defined. The Matrix object is modified in place.

        Arguments: elements {list} -- List of elements to put in the matrix

        Returns: boolean -- True if elements were added and False otherwise.
        &#34;&#34;&#34;
        if len(elements) == self._row_no * self._col_no:
            self._matrix = np.reshape(elements, (self._row_no, self._col_no))
            return True
        else:
            return False

    def transpose(self):
        &#34;&#34;&#34;
        This method finds and returns the transpose of the calling object. The
        calling object is NOT modified in place.

        Returns: Matrix -- A reference to the new transposed Matrix object
        &#34;&#34;&#34;
        retval = Matrix(self._col_no, self._row_no)
        retval._matrix = np.transpose(self._matrix)
        return retval

    def det(self):
        &#34;&#34;&#34;
        This method finds the determinant of the calling object.

        Returns: float -- The determinant value rounded up to two places or None
            if the request was invalid
        &#34;&#34;&#34;
        if self._row_no == self._col_no:
            return round(np.linalg.det(self._matrix), 2)
        else:
            return None

    def multiply_scalar(self, scalar):
        &#34;&#34;&#34;
        This method multiplies a scalar coefficient into the matrix.The calling
        object is NOT modified in place.

        Arguments: scalar -- The coefficient to multiply by

        Returns: Matrix -- A reference to the Matrix object with scalar
            multiplication applied
        &#34;&#34;&#34;
        retval = Matrix(self._row_no, self._col_no)
        retval._matrix = self._matrix * scalar
        return retval

    def inv(self):
        &#34;&#34;&#34;
        This method finds the inverse matrix of the calling object.The calling
        object is NOT modified in place.

        Returns: Matrix -- A reference to the inverse matix or None if the
            request was invalid
        &#34;&#34;&#34;
        if self.det() != 0 and self._row_no == self._col_no:
            retval = Matrix(self._row_no, self._col_no)
            inverse_array = np.matrix.round(np.linalg.inv(self._matrix), 2)
            retval._set_matrix_array(inverse_array)
            return retval
        else:
            return None

    def cofactor(self):
        &#34;&#34;&#34;
        This method finds the cofactor matrix of the calling object.The calling
        object is NOT modified in place.

        Returns: Matrix -- A reference to the cofactor matrix or None if the
            request was invalid
        &#34;&#34;&#34;
        if self._row_no == self._col_no:
            retval = Matrix(self._row_no, self._col_no)

            values = []
            for i in range(1, self._row_no + 1):
                for j in range(1, self._col_no + 1):
                    sign_factor = (-1)**(i + j)
                    remaining = self.find_minor(i, j)
                    cofactor = sign_factor * remaining.det()
                    values.append(cofactor)

            retval.insert_all(values)
            return retval
        else:
            return None

    def adjoint(self):
        &#34;&#34;&#34;
        This method finds the adjoint matrix of the calling object.The calling
        object is NOT modified in place.

        Returns: Matrix -- A reference to the adjoint matrix or None if the
            request was invalid
        &#34;&#34;&#34;
        return self.cofactor().transpose()

    def find_minor(self, row, column):
        &#34;&#34;&#34;
        This method finds the minor of the calling object at the given
        position.The calling object is NOT modified in place.

        Arguments: row -- The minor row column -- The minor column

        Returns: Matrix -- A reference to the minor matrix or None if the
            request was invalid
        &#34;&#34;&#34;
        if self._row_no == self._col_no and self._row_no &gt; 1 and self._col_no &gt; 1:
            if row &gt; 0 and column &gt; 0 and row &lt;= self._row_no and column &lt;= self._col_no:
                retval = Matrix(self._row_no - 1, self._col_no - 1)
                values = []

                for i in range(1, self._row_no + 1):
                    for j in range(1, self._col_no + 1):
                        if i == row or j == column:
                            pass
                        else:
                            values.append(self._matrix[i - 1][j - 1])

                retval.insert_all(values)
                return retval
            else:
                return None
        else:
            return None

    def is_boolean(self):
        &#34;&#34;&#34;
        This method checks to see if a matrix is a zero-one matrix. That is, it
        checks to see if all the elements in the matrix are either 0 or one.

        Returns: boolean -- True or False depending on wheter or not it is a
            zero-one matrix or not
        &#34;&#34;&#34;
        for i in range(1, self._row_no + 1):
            for j in range(1, self._col_no + 1):
                value = self._matrix[i - 1][j - 1]
                if value != 1 and value != 0:
                    return False

        return True

    def boolean_power(self, pow):
        &#34;&#34;&#34;
        This method finds the boolean power of the given matrix raised to the
        pow parameter.The calling object is NOT modified in place.

        Arguments: pow -- The power

        Returns: Matrix -- A reference to the resulting matrix or None if the
            request was invalid.For a power of 0 the identity matrix of input
            matrix row size will be returned.
        &#34;&#34;&#34;
        if pow == 0:
            return get_identity_matrix(self._row_no)
        if pow &gt; 0:
            retval = self
            for i in range(pow - 1):
                retval = retval.boolean_product(self)
                if retval is None:
                    return None
            return retval
        else:
            return None

    def boolean_product(self, other):
        &#34;&#34;&#34;
        This method finds the boolean product of the given matries.The calling
        object is NOT modified in place.

        Arguments: other -- The matrix object with which a boolean product is to
            be computed

        Returns: Matrix -- A reference to the resulting matrix or None if the
            request was invalid.
        &#34;&#34;&#34;
        if isinstance(other, Matrix):
            if self._col_no == other._row_no:
                values = []
                for i in range(1, self._row_no + 1):
                    for j in range(1, self._col_no + 1):
                        res_val = 0
                        for k in range(1, self._col_no + 1):
                            value1 = self._matrix[i - 1][k - 1]
                            value2 = other._matrix[k - 1][j - 1]
                            if (value1 == 0 or value1 == 1) and (
                                    value2 == 0 or value2 == 1):
                                res_val = res_val | (value1 &amp; value2)
                            else:
                                return None
                        values.append(res_val)
                retval = Matrix(self._row_no, other._col_no)
                retval.insert_all(values)
                return retval
            else:
                return None
        else:
            return None

    def __add__(self, other):
        &#34;&#34;&#34;
        This method finds the addition of the given matries.The calling object
        is NOT modified in place.

        Arguments: other -- The matrix object to be added

        Returns: Matrix -- A reference to the resulting matrix or None if the
            request was invalid.
        &#34;&#34;&#34;
        if dimensions_match(self, other):
            retval = Matrix(self._row_no, self._col_no)
            retval._matrix = np.add(self._matrix, other._matrix)
            return retval
        else:
            return None

    def __sub__(self, other):
        &#34;&#34;&#34;
        This method finds the subtraction of the given matries.The calling
        object is NOT modified in place.

        Arguments: other -- The matrix object to be subtracted

        Returns: Matrix -- A reference to the resulting matrix or None if the
            request was invalid.
        &#34;&#34;&#34;
        if dimensions_match(self, other):
            retval = Matrix(self._row_no, self._col_no)
            retval._matrix = np.subtract(self._matrix, other._matrix)
            return retval
        else:
            return None

    def __mul__(self, other):
        &#34;&#34;&#34;
        This method finds the multiplication of the given matries.The calling
        object is NOT modified in place.

        Arguments: other -- The matrix object to be multiplied

        Returns: Matrix -- A reference to the resulting matrix or None if the
            request was invalid.
        &#34;&#34;&#34;
        if self._col_no == other._row_no:
            retval = Matrix(self._row_no, other._col_no)
            retval._matrix = np.dot(self._matrix, other._matrix)
            return retval
        else:
            return None

    def __pow__(self, pow):
        &#34;&#34;&#34;
        This method finds the power of the given matrix raised to the pow
        parameter.The calling object is NOT modified in place.

        Arguments: pow -- The power

        Returns: Matrix -- A reference to the resulting matrix or None if the
            request was invalid. For a power of 0 the identity matrix of input
            matrix row size will be returned.
        &#34;&#34;&#34;
        if pow == 0:
            return get_identity_matrix(self._row_no)
        if pow &gt; 0:
            retval = self
            for i in range(pow - 1):
                retval = retval * self
                if retval is None:
                    return None
            return retval
        else:
            return None

    def __lshift__(self, shift_val):
        &#34;&#34;&#34;
        This method left shifts each value in the matrix. The calling object is
        NOT modified in place.

        Arguments: shift_val {int} -- The shift value

        Returns: Matrix -- A reference to the resulting matrix. or None if the
        request was invalid
        &#34;&#34;&#34;

        if isinstance(shift_val, int):
            retval = Matrix(self._row_no, self._col_no)
            for i in range(self._row_no):
                for j in range(self._col_no):
                    if isinstance(self._matrix[i][j], np.int32):
                        retval._matrix[i][j] = self._matrix[i][j] &lt;&lt; shift_val
                    else:
                        return None
            return retval
        else:
            return None

    def __rshift__(self, shift_val):
        &#34;&#34;&#34;
        This method right shifts each value in the matrix. The calling object is
        NOT modified in place.

        Arguments: shift_val {int} -- The shift value

        Returns: Matrix -- A reference to the resulting matrix. or None if the
        request was invalid
        &#34;&#34;&#34;
        if isinstance(shift_val, int):
            retval = Matrix(self._row_no, self._col_no)
            for i in range(self._row_no):
                for j in range(self._col_no):
                    if isinstance(self._matrix[i][j], np.int32):
                        retval._matrix[i][j] = self._matrix[i][j] &gt;&gt; shift_val
                    else:
                        return None
            return retval
        else:
            return None

    def __and__(self, other):
        &#34;&#34;&#34;
        This method finds the elementwise bitwise AND of the given matries.The
        calling object is NOT modified in place.

        Arguments: other -- The matrix object to be AND-ed with

        Returns: Matrix -- A reference to the resulting matrix or None if the
            request was invalid.
        &#34;&#34;&#34;
        if dimensions_match(self, other):
            retval = Matrix(self._row_no, self._col_no)
            retval._matrix = np.bitwise_and(self._matrix, other._matrix)
            return retval
        else:
            return None

    def __or__(self, other):
        &#34;&#34;&#34;
        This method finds the elementwise bitwise OR of the given matries.The
        calling object is NOT modified in place.

        Arguments: other -- The matrix object to be OR-ed with

        Returns: Matrix -- A reference to the resulting matrix or None if the
            request was invalid.
        &#34;&#34;&#34;
        if dimensions_match(self, other):
            retval = Matrix(self._row_no, self._col_no)
            retval._matrix = np.bitwise_or(self._matrix, other._matrix)
            return retval
        else:
            return None

    def __xor__(self, other):
        &#34;&#34;&#34;
        This method finds the elementwise bitwise XOR of the given matries.The
        calling object is NOT modified in place.

        Arguments: other -- The matrix object to be XOR-ed with

        Returns: Matrix -- A reference to the resulting matrix or None if the
            request was invalid.
        &#34;&#34;&#34;
        if dimensions_match(self, other):
            retval = Matrix(self._row_no, self._col_no)
            retval._matrix = np.bitwise_xor(self._matrix, other._matrix)
            return retval
        else:
            return None

    def __str__(self):
        &#34;&#34;&#34;
        This method retruns the string representation of the matrix.

        Returns: str -- The matrix&#39;s string representation
        &#34;&#34;&#34;
        return str(self._matrix)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="matrix.Matrix.adjoint"><code class="name flex">
<span>def <span class="ident">adjoint</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method finds the adjoint matrix of the calling object.The calling
object is NOT modified in place.</p>
<p>Returns: Matrix &ndash; A reference to the adjoint matrix or None if the
request was invalid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def adjoint(self):
    &#34;&#34;&#34;
    This method finds the adjoint matrix of the calling object.The calling
    object is NOT modified in place.

    Returns: Matrix -- A reference to the adjoint matrix or None if the
        request was invalid
    &#34;&#34;&#34;
    return self.cofactor().transpose()</code></pre>
</details>
</dd>
<dt id="matrix.Matrix.boolean_power"><code class="name flex">
<span>def <span class="ident">boolean_power</span></span>(<span>self, pow)</span>
</code></dt>
<dd>
<div class="desc"><p>This method finds the boolean power of the given matrix raised to the
pow parameter.The calling object is NOT modified in place.</p>
<p>Arguments: pow &ndash; The power</p>
<p>Returns: Matrix &ndash; A reference to the resulting matrix or None if the
request was invalid.For a power of 0 the identity matrix of input
matrix row size will be returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def boolean_power(self, pow):
    &#34;&#34;&#34;
    This method finds the boolean power of the given matrix raised to the
    pow parameter.The calling object is NOT modified in place.

    Arguments: pow -- The power

    Returns: Matrix -- A reference to the resulting matrix or None if the
        request was invalid.For a power of 0 the identity matrix of input
        matrix row size will be returned.
    &#34;&#34;&#34;
    if pow == 0:
        return get_identity_matrix(self._row_no)
    if pow &gt; 0:
        retval = self
        for i in range(pow - 1):
            retval = retval.boolean_product(self)
            if retval is None:
                return None
        return retval
    else:
        return None</code></pre>
</details>
</dd>
<dt id="matrix.Matrix.boolean_product"><code class="name flex">
<span>def <span class="ident">boolean_product</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>This method finds the boolean product of the given matries.The calling
object is NOT modified in place.</p>
<p>Arguments: other &ndash; The matrix object with which a boolean product is to
be computed</p>
<p>Returns: Matrix &ndash; A reference to the resulting matrix or None if the
request was invalid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def boolean_product(self, other):
    &#34;&#34;&#34;
    This method finds the boolean product of the given matries.The calling
    object is NOT modified in place.

    Arguments: other -- The matrix object with which a boolean product is to
        be computed

    Returns: Matrix -- A reference to the resulting matrix or None if the
        request was invalid.
    &#34;&#34;&#34;
    if isinstance(other, Matrix):
        if self._col_no == other._row_no:
            values = []
            for i in range(1, self._row_no + 1):
                for j in range(1, self._col_no + 1):
                    res_val = 0
                    for k in range(1, self._col_no + 1):
                        value1 = self._matrix[i - 1][k - 1]
                        value2 = other._matrix[k - 1][j - 1]
                        if (value1 == 0 or value1 == 1) and (
                                value2 == 0 or value2 == 1):
                            res_val = res_val | (value1 &amp; value2)
                        else:
                            return None
                    values.append(res_val)
            retval = Matrix(self._row_no, other._col_no)
            retval.insert_all(values)
            return retval
        else:
            return None
    else:
        return None</code></pre>
</details>
</dd>
<dt id="matrix.Matrix.cofactor"><code class="name flex">
<span>def <span class="ident">cofactor</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method finds the cofactor matrix of the calling object.The calling
object is NOT modified in place.</p>
<p>Returns: Matrix &ndash; A reference to the cofactor matrix or None if the
request was invalid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cofactor(self):
    &#34;&#34;&#34;
    This method finds the cofactor matrix of the calling object.The calling
    object is NOT modified in place.

    Returns: Matrix -- A reference to the cofactor matrix or None if the
        request was invalid
    &#34;&#34;&#34;
    if self._row_no == self._col_no:
        retval = Matrix(self._row_no, self._col_no)

        values = []
        for i in range(1, self._row_no + 1):
            for j in range(1, self._col_no + 1):
                sign_factor = (-1)**(i + j)
                remaining = self.find_minor(i, j)
                cofactor = sign_factor * remaining.det()
                values.append(cofactor)

        retval.insert_all(values)
        return retval
    else:
        return None</code></pre>
</details>
</dd>
<dt id="matrix.Matrix.det"><code class="name flex">
<span>def <span class="ident">det</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method finds the determinant of the calling object.</p>
<p>Returns: float &ndash; The determinant value rounded up to two places or None
if the request was invalid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def det(self):
    &#34;&#34;&#34;
    This method finds the determinant of the calling object.

    Returns: float -- The determinant value rounded up to two places or None
        if the request was invalid
    &#34;&#34;&#34;
    if self._row_no == self._col_no:
        return round(np.linalg.det(self._matrix), 2)
    else:
        return None</code></pre>
</details>
</dd>
<dt id="matrix.Matrix.find_minor"><code class="name flex">
<span>def <span class="ident">find_minor</span></span>(<span>self, row, column)</span>
</code></dt>
<dd>
<div class="desc"><p>This method finds the minor of the calling object at the given
position.The calling object is NOT modified in place.</p>
<p>Arguments: row &ndash; The minor row column &ndash; The minor column</p>
<p>Returns: Matrix &ndash; A reference to the minor matrix or None if the
request was invalid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_minor(self, row, column):
    &#34;&#34;&#34;
    This method finds the minor of the calling object at the given
    position.The calling object is NOT modified in place.

    Arguments: row -- The minor row column -- The minor column

    Returns: Matrix -- A reference to the minor matrix or None if the
        request was invalid
    &#34;&#34;&#34;
    if self._row_no == self._col_no and self._row_no &gt; 1 and self._col_no &gt; 1:
        if row &gt; 0 and column &gt; 0 and row &lt;= self._row_no and column &lt;= self._col_no:
            retval = Matrix(self._row_no - 1, self._col_no - 1)
            values = []

            for i in range(1, self._row_no + 1):
                for j in range(1, self._col_no + 1):
                    if i == row or j == column:
                        pass
                    else:
                        values.append(self._matrix[i - 1][j - 1])

            retval.insert_all(values)
            return retval
        else:
            return None
    else:
        return None</code></pre>
</details>
</dd>
<dt id="matrix.Matrix.get_col_no"><code class="name flex">
<span>def <span class="ident">get_col_no</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the number of columns in the calling matrix.</p>
<p>Returns: int &ndash; The number of columns</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_col_no(self):
    &#34;&#34;&#34;
    Returns the number of columns in the calling matrix.

    Returns: int -- The number of columns
    &#34;&#34;&#34;
    return self._col_no</code></pre>
</details>
</dd>
<dt id="matrix.Matrix.get_row_no"><code class="name flex">
<span>def <span class="ident">get_row_no</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the number of rows in the calling matrix.</p>
<p>Returns: int &ndash; The number of rows</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_row_no(self):
    &#34;&#34;&#34;
    Returns the number of rows in the calling matrix.

    Returns: int -- The number of rows
    &#34;&#34;&#34;
    return self._row_no</code></pre>
</details>
</dd>
<dt id="matrix.Matrix.get_value"><code class="name flex">
<span>def <span class="ident">get_value</span></span>(<span>self, row, col)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the matrix value at the given position. Index starts at (1,1)</p>
<p>Arguments: row {int} &ndash; The row position of the element col {int} &ndash; The
column position of the element</p>
<p>Returns: The value stored at (row, col) or None if the position is
invalid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value(self, row, col):
    &#34;&#34;&#34;
    Returns the matrix value at the given position. Index starts at (1,1)

    Arguments: row {int} -- The row position of the element col {int} -- The
        column position of the element

    Returns: The value stored at (row, col) or None if the position is
        invalid
    &#34;&#34;&#34;
    if row &gt; 0 and col &gt; 0 and row &lt;= self._row_no and col &lt;= self._col_no:
        return self._matrix[row - 1][col - 1]
    else:
        return None</code></pre>
</details>
</dd>
<dt id="matrix.Matrix.insert_all"><code class="name flex">
<span>def <span class="ident">insert_all</span></span>(<span>self, elements)</span>
</code></dt>
<dd>
<div class="desc"><p>This method accepts a list of elements and initializes the matrix with
them. Make sure to pass as many elements in the list as there are spaces
in the matrix you defined. The Matrix object is modified in place.</p>
<p>Arguments: elements {list} &ndash; List of elements to put in the matrix</p>
<p>Returns: boolean &ndash; True if elements were added and False otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_all(self, elements):
    &#34;&#34;&#34;
    This method accepts a list of elements and initializes the matrix with
    them. Make sure to pass as many elements in the list as there are spaces
    in the matrix you defined. The Matrix object is modified in place.

    Arguments: elements {list} -- List of elements to put in the matrix

    Returns: boolean -- True if elements were added and False otherwise.
    &#34;&#34;&#34;
    if len(elements) == self._row_no * self._col_no:
        self._matrix = np.reshape(elements, (self._row_no, self._col_no))
        return True
    else:
        return False</code></pre>
</details>
</dd>
<dt id="matrix.Matrix.inv"><code class="name flex">
<span>def <span class="ident">inv</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method finds the inverse matrix of the calling object.The calling
object is NOT modified in place.</p>
<p>Returns: Matrix &ndash; A reference to the inverse matix or None if the
request was invalid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inv(self):
    &#34;&#34;&#34;
    This method finds the inverse matrix of the calling object.The calling
    object is NOT modified in place.

    Returns: Matrix -- A reference to the inverse matix or None if the
        request was invalid
    &#34;&#34;&#34;
    if self.det() != 0 and self._row_no == self._col_no:
        retval = Matrix(self._row_no, self._col_no)
        inverse_array = np.matrix.round(np.linalg.inv(self._matrix), 2)
        retval._set_matrix_array(inverse_array)
        return retval
    else:
        return None</code></pre>
</details>
</dd>
<dt id="matrix.Matrix.is_boolean"><code class="name flex">
<span>def <span class="ident">is_boolean</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method checks to see if a matrix is a zero-one matrix. That is, it
checks to see if all the elements in the matrix are either 0 or one.</p>
<p>Returns: boolean &ndash; True or False depending on wheter or not it is a
zero-one matrix or not</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_boolean(self):
    &#34;&#34;&#34;
    This method checks to see if a matrix is a zero-one matrix. That is, it
    checks to see if all the elements in the matrix are either 0 or one.

    Returns: boolean -- True or False depending on wheter or not it is a
        zero-one matrix or not
    &#34;&#34;&#34;
    for i in range(1, self._row_no + 1):
        for j in range(1, self._col_no + 1):
            value = self._matrix[i - 1][j - 1]
            if value != 1 and value != 0:
                return False

    return True</code></pre>
</details>
</dd>
<dt id="matrix.Matrix.multiply_scalar"><code class="name flex">
<span>def <span class="ident">multiply_scalar</span></span>(<span>self, scalar)</span>
</code></dt>
<dd>
<div class="desc"><p>This method multiplies a scalar coefficient into the matrix.The calling
object is NOT modified in place.</p>
<p>Arguments: scalar &ndash; The coefficient to multiply by</p>
<p>Returns: Matrix &ndash; A reference to the Matrix object with scalar
multiplication applied</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def multiply_scalar(self, scalar):
    &#34;&#34;&#34;
    This method multiplies a scalar coefficient into the matrix.The calling
    object is NOT modified in place.

    Arguments: scalar -- The coefficient to multiply by

    Returns: Matrix -- A reference to the Matrix object with scalar
        multiplication applied
    &#34;&#34;&#34;
    retval = Matrix(self._row_no, self._col_no)
    retval._matrix = self._matrix * scalar
    return retval</code></pre>
</details>
</dd>
<dt id="matrix.Matrix.set_value"><code class="name flex">
<span>def <span class="ident">set_value</span></span>(<span>self, row, col, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the matrix value at the given position. Index starts at (1,1)</p>
<p>Arguments: row {int} &ndash; The row position of the element col {int} &ndash; The
column position of the element</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_value(self, row, col, value):
    &#34;&#34;&#34;
    Sets the matrix value at the given position. Index starts at (1,1)

    Arguments: row {int} -- The row position of the element col {int} -- The
        column position of the element
    &#34;&#34;&#34;
    if row &gt; 0 and col &gt; 0 and row &lt;= self._row_no and col &lt;= self._col_no:
        self._matrix[row - 1][col - 1] = value
    else:
        return None</code></pre>
</details>
</dd>
<dt id="matrix.Matrix.transpose"><code class="name flex">
<span>def <span class="ident">transpose</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method finds and returns the transpose of the calling object. The
calling object is NOT modified in place.</p>
<p>Returns: Matrix &ndash; A reference to the new transposed Matrix object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transpose(self):
    &#34;&#34;&#34;
    This method finds and returns the transpose of the calling object. The
    calling object is NOT modified in place.

    Returns: Matrix -- A reference to the new transposed Matrix object
    &#34;&#34;&#34;
    retval = Matrix(self._col_no, self._row_no)
    retval._matrix = np.transpose(self._matrix)
    return retval</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="matrix.dimensions_match" href="#matrix.dimensions_match">dimensions_match</a></code></li>
<li><code><a title="matrix.get_identity_matrix" href="#matrix.get_identity_matrix">get_identity_matrix</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="matrix.Matrix" href="#matrix.Matrix">Matrix</a></code></h4>
<ul class="two-column">
<li><code><a title="matrix.Matrix.adjoint" href="#matrix.Matrix.adjoint">adjoint</a></code></li>
<li><code><a title="matrix.Matrix.boolean_power" href="#matrix.Matrix.boolean_power">boolean_power</a></code></li>
<li><code><a title="matrix.Matrix.boolean_product" href="#matrix.Matrix.boolean_product">boolean_product</a></code></li>
<li><code><a title="matrix.Matrix.cofactor" href="#matrix.Matrix.cofactor">cofactor</a></code></li>
<li><code><a title="matrix.Matrix.det" href="#matrix.Matrix.det">det</a></code></li>
<li><code><a title="matrix.Matrix.find_minor" href="#matrix.Matrix.find_minor">find_minor</a></code></li>
<li><code><a title="matrix.Matrix.get_col_no" href="#matrix.Matrix.get_col_no">get_col_no</a></code></li>
<li><code><a title="matrix.Matrix.get_row_no" href="#matrix.Matrix.get_row_no">get_row_no</a></code></li>
<li><code><a title="matrix.Matrix.get_value" href="#matrix.Matrix.get_value">get_value</a></code></li>
<li><code><a title="matrix.Matrix.insert_all" href="#matrix.Matrix.insert_all">insert_all</a></code></li>
<li><code><a title="matrix.Matrix.inv" href="#matrix.Matrix.inv">inv</a></code></li>
<li><code><a title="matrix.Matrix.is_boolean" href="#matrix.Matrix.is_boolean">is_boolean</a></code></li>
<li><code><a title="matrix.Matrix.multiply_scalar" href="#matrix.Matrix.multiply_scalar">multiply_scalar</a></code></li>
<li><code><a title="matrix.Matrix.set_value" href="#matrix.Matrix.set_value">set_value</a></code></li>
<li><code><a title="matrix.Matrix.transpose" href="#matrix.Matrix.transpose">transpose</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>